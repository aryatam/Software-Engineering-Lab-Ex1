<div dir="rtl" align="right" style="font-family: sans-serif;">

# پاسخ پرسش‌ها

در این قسمت پاسخ سوالات خواسته شده را می‌دهیم.

---

## پوشه‌ی `.git` چیست؟

پوشه‌ی `.git` یک دایرکتوری پنهان در ریشه‌ی پروژه‌های Git است که تمامی اطلاعات حیاتی مرتبط با تاریخچه و وضعیت پروژه را در خود نگه می‌دارد. این پوشه به‌نوعی مغز پروژه‌ی Git محسوب می‌شود و شامل اطلاعاتی مانند commitها، شاخه‌ها (branches)، تنظیمات محلی، وضعیت فایل‌ها (staging)، تگ‌ها، و اطلاعات remote repository است. زمانی که شما دستور `git init` را در یک دایرکتوری اجرا می‌کنید، Git این پوشه را ایجاد می‌کند و آن را به یک مخزن محلی تبدیل می‌نماید. تمام اعمال و تغییرات در پروژه عملاً در درون این پوشه ثبت و نگهداری می‌شوند.

## منظور از Atomic بودن در Commit و Pull Request چیست؟

منظور از atomic بودن در commit یا pull request آن است که هر تغییر باید به‌صورت یک واحد کامل، مستقل و منطقی ذخیره شود. یک commit اتمی تنها باید شامل یک هدف مشخص و معنادار باشد، مثلاً افزودن یک ویژگی خاص یا اصلاح یک باگ مشخص. چنین commitهایی بررسی، تست و بازگشت آن‌ها را در صورت نیاز بسیار ساده‌تر می‌کند. همین ایده در مورد pull request نیز صدق می‌کند: یک pull request اتمی فقط باید شامل یک موضوع باشد و نه ترکیبی از چندین اصلاح مختلف. این روش باعث خوانایی بیشتر تاریخچه پروژه و افزایش کیفیت همکاری در تیم می‌شود.

## تفاوت بین `fetch`، `pull`، `merge`، `rebase` و `cherry-pick`

دستور `git fetch` صرفاً تغییرات جدید موجود در مخزن remote را دریافت می‌کند و در شاخه‌های track شده ذخیره می‌نماید، اما این تغییرات را با شاخه‌ی فعلی ادغام نمی‌کند. در مقابل، `git pull` این کار را انجام می‌دهد؛ یعنی ابتدا fetch می‌کند و سپس به‌طور خودکار merge انجام می‌دهد و تغییرات remote را در شاخه‌ی شما اعمال می‌نماید. اگر بخواهید کنترل بیشتری بر نحوه‌ی ادغام داشته باشید، بهتر است ابتدا از fetch استفاده کرده و سپس خودتان تصمیم بگیرید که merge انجام دهید یا rebase. merge شاخه‌ای را به شاخه‌ی دیگر وصل می‌کند و در صورت نیاز commit ادغامی (merge commit) تولید می‌کند. rebase اما تاریخچه شاخه‌ای را بازنویسی می‌کند و commitهای آن را به انتهای شاخه‌ی فعلی منتقل می‌کند تا تاریخچه تمیزتر شود. در نهایت، `git cherry-pick` ابزاری است که به شما اجازه می‌دهد تنها یک یا چند commit خاص را از شاخه‌ای دیگر انتخاب کرده و به شاخه‌ی فعلی‌تان اضافه کنید، بدون آن‌که باقی تغییرات آن شاخه منتقل شوند.

## تفاوت بین `reset`، `revert`، `restore`، `switch`، `checkout`

دستور `git reset` برای بازگرداندن HEAD به commitی قدیمی‌تر استفاده می‌شود و می‌تواند stage و یا working directory را نیز بسته به حالت اجرا پاکسازی کند. این دستور بیشتر در بازنویسی تاریخچه و لغو commitهای اخیر کاربرد دارد. در مقابل، `git revert` تغییرات یک commit را با ایجاد یک commit جدید معکوس می‌کند و در نتیجه تاریخچه را حفظ می‌نماید. این روش برای بازگرداندن تغییرات در پروژه‌هایی که از مخازن عمومی استفاده می‌کنند بسیار امن‌تر است. دستور `git restore` برای بازگرداندن فایل‌ها از commit یا stage قبلی به‌کار می‌رود، بدون آن‌که تاریخچه را تغییر دهد. `git switch` دستوری جدیدتر و ساده‌تر برای جابه‌جایی بین شاخه‌ها است و به‌نوعی جایگزین `git checkout` شده است. checkout قدیمی‌تر است و هم برای تغییر شاخه‌ها و هم برای بازگرداندن فایل‌ها به حالت خاص استفاده می‌شد، اما به‌دلیل پیچیدگی‌اش به دو دستور جداگانه‌ی `switch` و `restore` تقسیم شده است.

## Stage (یا Index) چیست؟ دستور `stash` چه کاری انجام می‌دهد؟

مرحله‌ی stage یا index در Git، ناحیه‌ای موقت میان وضعیت فایل‌های کاری و commitها است. زمانی که فایلی را با دستور `git add` به stage اضافه می‌کنید، Git آن را برای commit بعدی علامت‌گذاری می‌کند، اما هنوز وارد تاریخچه نشده است. این امکان را می‌دهد تا بخشی از تغییرات را به‌صورت انتخابی commit کنید. دستور `git stash` برای زمانی است که شما تغییراتی در فایل‌ها دارید ولی نمی‌خواهید آن‌ها را commit کنید و در عین حال لازم است به حالت قبلی پروژه بازگردید. در این حالت می‌توانید stash کنید، یعنی تغییرات را موقتاً ذخیره کرده و بعداً آن‌ها را بازگردانید و ادامه دهید. این ابزار برای سوئیچ بین شاخه‌ها یا کار روی چند ویژگی به‌صورت موازی بسیار مفید است.

## Snapshot چیست؟ ارتباط آن با Commit چیست؟

در Git، snapshot به تصویری کامل از وضعیت فایل‌ها در یک زمان مشخص اشاره دارد. زمانی که commit می‌کنید، Git کل وضعیت پروژه را به‌صورت یک snapshot ذخیره می‌کند، نه فقط لیستی از تغییرات (diff). اگرچه Git در پشت‌صحنه با استفاده از مکانیزم‌های بهینه‌سازی مثل hash و pointer فقط تفاوت‌ها را ذخیره می‌کند، اما از دید کاربر هر commit در واقع نماینده‌ی یک snapshot کامل است. این مدل باعث می‌شود برگشت به وضعیت‌های گذشته ساده، سریع و دقیق باشد و کل پروژه در هر زمان قابل بازیابی باشد.

## تفاوت‌های local repository و remote repository

مخزن محلی (local repository) همان چیزی است که روی سیستم شما ایجاد می‌شود، مثلاً با `git init` یا `git clone`. این مخزن فقط برای شما قابل دسترسی است و می‌توانید آزادانه commit، branch و سایر عملیات را در آن انجام دهید. اما مخزن راه‌دور (remote repository) مانند GitHub یا GitLab، نسخه‌ای از مخزن است که روی سرور دیگری قرار دارد و برای اشتراک‌گذاری با دیگران استفاده می‌شود. برای ارسال تغییرات به مخزن راه‌دور از `git push` و برای دریافت تغییرات از آن از `git pull` یا `git fetch` استفاده می‌شود. تفاوت اصلی در محل ذخیره و هدف استفاده است: محلی برای توسعه شخصی، راه‌دور برای همکاری تیمی و پشتیبان‌گیری.



</div>